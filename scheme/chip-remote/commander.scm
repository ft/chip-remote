;; Copyright (c) 2018-2024 chip-remote workers, All rights reserved.
;;
;; Terms for redistribution and use can be found in LICENCE.

(define-module (chip-remote commander)
  #:use-module (ice-9 match)
  #:use-module (ice-9 optargs)
  #:use-module (ice-9 pretty-print)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)
  #:use-module ((chip-remote decode) #:prefix cr:)
  #:use-module (chip-remote item)
  #:use-module (chip-remote device)
  #:use-module (chip-remote device access)
  #:use-module (chip-remote frontend)
  #:use-module (chip-remote named-value)
  #:use-module (chip-remote page-map)
  #:use-module (chip-remote modify)
  #:use-module (chip-remote protocol)
  #:use-module (chip-remote semantics)
  #:export (make-commander))

(define (pp obj . args)
  (apply pretty-print (cons* obj #:width 80 #:max-expr-width 100 args)))

(define-record-type <cmdr-state>
  (make-cmdr-state device connection interface address default decode open-hook)
  cmdr-state?
  (device     get-device     update-device!)
  (connection get-connection)
  (interface  get-interface  update-interface!)
  (address    get-address)
  (default    get-default)
  (decode     get-decoder    set-decoder!)
  (open-hook  get-open-hook))

(define (show cmdr spec value)
  (let ((run-decoder (get-decoder cmdr)))
    (run-decoder spec value)))

(define (commander:decode-all state)
  (let ((device (get-device state)))
    (show state device (current-device-state device))))

(define *void* (if #f #f))

(define (must-be-connected state)
  (let ((conn (get-connection state)))
    (unless (proto-connected? conn)
      (throw 'connection-not-opened conn)))
  *void*)

(define (make-args c? s args)
  (if c?
      (cons* (get-connection s)
             (get-interface s)
             (get-device s)
             args)
      (cons (get-device s) args)))

(define (update! c? s f args)
  (when c? (must-be-connected s))
  (update-device! s (apply f (make-args c? s args)))
  *void*)

(define commander-help
  (case-lambda
    ((dev) (display "Chip Commander Object

These objects accept messages in there parameter lists in order to perform
various common action upon the device connected to the object. You have
accessed this help by issuing:

  (foobar 'help)

It is possible to get information on various sub-commands like this as well:

  (foobar 'help 'pull!)

Additionally available topics: pull!, push!.
"))

    ((dev subject)
     (case subject
       ((pull!) (display
                 "Update local state of with data from connected device 

This command downloads all data from a connected device and updates its device
object's internal state with this data. This is useful to do often after
connecting to a chip-remote firmware in order to synchronise with the actual
hip state.
"))
       ((push!) (display "Transfer object state into connected device

The commander objects carries a device object, keeping track of its state. This
state can be modified locally only, without transmitting changes to the device
in question. This command transfers the local state into the connected device.
"))))))

(define* (make-commander #:key
                         device connection default (decode cr:decode)
                         interface address (open-hook (lambda (c ifc dev) #t)))
  "Return a device commander object

The chip-remote library provides a powerful framework to express configuration
interfaces. The original intend was to be able to interactively play with
devices that employ these interfaces (hence the name *chip-remote*). The
commander objects constructed by this function serve as frontends that hide a
lot of the flexibility of the library in order to reduce the amount of typing
required by interactive users.

Commanders tie together devices and connections. They also store a copy of the
chip's register memory. This representation can be manipulated and sent to the
device in question.

The constructor takes a number of keyword arguments:

- ‘#:device’ → References the description of the device that is to be
  controlled.

- ‘#:connection’ → Refers to the connection the device can be accessed through.

- ‘#:interface’ → The peripheral interface to use with the device in question.

- ‘#:address’ → Configure the address of the device within the RCCEP port, if
  applicable. Defaults to 0.

- ‘#:data’ → This can be used to initialise the object's register memory. The
  datum has to fit the device referenced by the commander object. This defaults
  to the device's default values as generated by ‘device-default’.

- ‘#:decode’ → The object can decode parts of it register memory. This is the
  decoder frontend used to present the results. The default is the ‘decode’
  function from the ‘`(chip-remote decode)`’ module. Another possible value is
  ‘decode-to-text’.

- ‘#:open-hook’ → A function of two arguments (‘connection’, ‘port-index’) that
  is called after the object's ‘open!’ operation has finished. This can be used
  to initialise firmwares running in a remote controller.

Objects returned by this constructor are designed for interactive use in a
Scheme REPL. The objects implement a command interface to interact with the
connected device.

Note that these objects, unlike most of the rest of the library perform lots of
mutations: On connected device of course, and also on their local register
memory copy."

  (unless (device? device)
    (throw 'cr-missing-data 'device device))

  (let ((state (make-cmdr-state device connection interface
                                address default decode
                                open-hook)))

    (lambda args
      (match args
        (() (commander:decode-all state))
        (('help)         (commander-help (get-device state)))
        (('help subject) (commander-help (get-device state) subject))
        ;; TODO: Set address for I2C ports in ‘setup’?
        (('setup!) (begin
                     (must-be-connected state)
                     (let ((c (get-connection state))
                           (ifc (get-interface state))
                           (dev (get-device state))
                           (hook (get-open-hook state)))
                       (unless (cr-access c)
                         (proto-engage! c))
                       (device-setup! c ifc device)
                       (hook c ifc dev))))

        (('decoder! f) (set-decoder! state f))

        (('pull!)      (update! #t state cr:pull! '()))
        (('push!)      (update! #t state cr:push! '()))
        (('reset!)     (update! #f state cr:reset (list (get-default state))))
        (('connection) (get-connection state))
        (('data)       (current-device-state (get-device state)))
        (('device)     (get-device state))

        (('load! datum)    (update! #t state cr:load '()))
        (('set! kv ...)
         (catch 'cr/invalid-value-for-item
           (lambda () (update! #f state cr:set kv))
           (lambda args
             (match args
               (('cr/invalid-value-for-item value item)
                (format #t "set!: Invalid value: ~a~%~%" value)
                (match (item-range item)
                  (('none)
                   (format #t "Failed update with ‘none’ range?~%")
                   (format #t "This sounds like a bug in chip-remote!~%"))
                  (('range a b)
                   (format #t "Value out of range: (>= ~a) (<= ~a)~%" a b))
                  (('enumeration . lst)
                   (format #t "Allowed values: ~a~%" lst))
                  (('table table)
                   (format #t "Key Value Table:~%~%")
                   (pp (if (named-value? table)
                           (value-data table)
                           table)
                       #:per-line-prefix "    "))))
               (_ (apply throw args)))
             *void*)))
        (('change! kv ...) (update! #t state cr:change! kv))

        (('history . args) (apply device-history (cons (get-device state) args)))
        (('diff . args)    (apply device-diff (cons (get-device state) args)))
        (('decode)      (commander:decode-all state))
        (('decode #:address . address)
         (let ((part (apply device-ref (cons (get-device state) address)))
               (value (apply value-at-address
                             (cons (current-device-state (get-device state))
                                   address))))
           (show state part (if (item? part)
                                (item-get part value)
                                value))))
        (('decode . addr)
         (let* ((device (get-device state))
                (data (current-device-state device))
                (extr (device-extract device data addr)))
           (show state (assq-ref extr 'part) (assq-ref extr 'item))))

        (('addresses) (device-address-map (get-device state)))
        (('canonical . addr)
         (apply device-canonical (cons (get-device state) addr)))

        (_ (throw 'unknown-command args))))))
