#!/usr/bin/perl

# Copyright 2012 Frank Terbeck <ft@bewatermyfriend.org>, All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# AUTHOR OR CONTRIBUTORS OF THE PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# This script's job is it to simulate the actual `chip-remote' hardware via one
# of the operating system's virtual terminal devices. It allows for quick
# testing and extension of the serial protocol between the host and the slave
# board. The test-suite could possibly use this as well.

use strict;
use warnings;
use diagnostics;

use English qw{ -no_match_vars };
use POSIX qw{ :termios_h };
use IO::Pty;

my ($NAME, $VERSION) = (q{boardsimu}, q{BOARDSIMU-2012-07-26});
my (%cb, %cnf, $done, $state);

### Callbacks #################################################################

%cb = (
    'HI'      => { state => q{init},
                   code  => sub { $state = q{main};
                                  return "Hi there, stranger." } },
    'VERSION' => { state => q{main},
                   code  => sub { return $VERSION } },
    'BYE'     => { state => q{main},
                   code  => sub { $done = 1 unless ($cnf{endless});
                                  $state = q{init};
                                  return "Have a nice day." } }
);

###############################################################################

%cnf = (
    delay => 0,
    endless => 0
);

do {
    sub usage {
        print q{
 Usage: boardsimu [OPTION(s)]

  --help, -h             Display this help text.
  --delay, -d <N>        Sleep for N seconds after reading intput.
  --endless, -e          Do not quit after "BYE".

};
    }

    use Getopt::Long;
    my ($rc);

    Getopt::Long::Configure(
        'require_order', 'no_gnu_compat', 'auto_abbrev',
        'no_ignore_case', 'bundling');

    $rc = GetOptions ( "help|h" => sub { usage; exit 0 },
                       "delay|d=i" => sub { $cnf{delay} = $_[1] },
                       "endless|e", => sub { $cnf{endless} = 1 } );

    if (!$rc) {
        usage;
        exit 1;
    }
};

my ($fh, $dev, $pty);

sub board_rx {
    my ($input) = @_;
    $input =~ s/[\r\n]+//;
    print " >>> " . $input . "\n";
    sleep $cnf{delay} if ($cnf{delay} > 0);
    return $input;
}

sub board_tx {
    my ($dev, $output) = @_;
    print " <<< " . $output . "\n";
    print $dev "$output\n";
}

$dev = POSIX::Termios->new;
$pty = IO::Pty->new;
$fh = $pty->slave;

print "Connecting to device `" . $fh->ttyname . "'...\n";

# Setup serial device...
$dev->getattr(fileno($fh)) or die "Could not get attributes: $ERRNO\n";

$dev->setispeed(B19200) or die "Could not set input speed: $ERRNO\n";
$dev->setospeed(B19200) or die "Could not set output speed: $ERRNO\n";

$dev->setcflag(($dev->getcflag
                   | (CSIZE | PARENB | CS8 | CREAD | CLOCAL | HUPCL))
                   & ~(IXON | IXOFF));

$dev->setiflag($dev->getiflag
                   | IGNBRK);

$dev->setlflag($dev->getlflag
                   & ~(ICANON | ECHO | ECHONL | ECHOK | ECHONL));

$dev->setoflag($dev->getoflag
                   & ~(OPOST));

$dev->setcc(VMIN, 1);
$dev->setcc(VTIME, 0);

$dev->setattr(fileno($fh), TCSANOW) or die "Could not set attributes: $ERRNO\n";

# Read-Reply loop
$done = 0;
$state = q{init};
RR: while (my $input = <$pty>) {
    my (@cmd, $f);

    $input = board_rx($input);
    @cmd = split /\s+/, $input;
    $f = $cb{$cmd[0]};

    if (defined $f->{code} and ref($f->{code}) eq q{CODE}) {
        my $ret = $f->{code}->(\@cmd) if ($state eq $f->{state});
        board_tx($pty, (defined $ret) ? $ret : q{WTF});
    } else {
        board_tx($pty, q{UNKNOWN-COMMAND});
    }

    last RR if ($done);
}

sleep 1;
close $fh;
