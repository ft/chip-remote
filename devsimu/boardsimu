#!/usr/bin/perl

# Copyright 2012 Frank Terbeck <ft@bewatermyfriend.org>, All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# AUTHOR OR CONTRIBUTORS OF THE PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# This script's job is it to simulate the actual `chip-remote' hardware via one
# of the operating system's virtual terminal devices. It allows for quick
# testing and extension of the serial protocol between the host and the slave
# board. The test-suite could possibly use this as well.

use strict;
use warnings;
use diagnostics;

use English qw{ -no_match_vars };
use POSIX qw{ :termios_h };
use IO::Pty;

my ($NAME, $VERSION) = (q{boardsimu}, q{BOARDSIMU-2012-07-26});
my (%cb, %cnf, $done, $state);

### Callbacks #################################################################

sub cb_features;
sub cb_more;

%cb = (
    'HI' => { state => q{init},
              code  => sub { $state = q{main};
                             return "Hi there, stranger." } },
    'VERSION' => { state => q{main},
                   code  => sub { return $VERSION } },
    'FEATURES' => { state => q{main},
                    code  => sub { $state = q{features};
                                   return cb_features(@_) } },
    'MORE' => { state => [ qw{ features } ],
                code  => \&cb_more },
    'BYE' => { state => q{main},
               code  => sub { $done = 1 unless ($cnf{endless});
                              $state = q{init};
                              return "Have a nice day." } }
);

my $__list_cnt;
sub __cb_list_more {
    my ($l, $c, $p, $cmd) = @_;
    shift; shift; shift;

    return "MALFORMED-COMMAND" if ($#_ != 0);

    if ($cmd eq $c) {
        $__list_cnt = 0;
    } else {
        $__list_cnt++;
    }

    if ($__list_cnt > $#{ $l }) {
        $state = $p;
        return "DONE";
    }

    return $l->[$__list_cnt];
}

sub cb_features {
    my @f = ( qw{ SPI SINGLE } );
    return __cb_list_more(\@f, 'FEATURES', 'main', @_);
}

sub cb_more {
    my ($cmd) = @_;

    return cb_features($cmd) if ($state eq q{features});
    return "BUG-SHOULD-NOT-BE-REACHED";
}

###############################################################################

%cnf = (
    delay => 0,
    endless => 0
);

do {
    sub usage {
        print q{
 Usage: boardsimu [OPTION(s)]

  --help, -h             Display this help text.
  --delay, -d <N>        Sleep for N seconds after reading intput.
  --endless, -e          Do not quit after "BYE".

};
    }

    use Getopt::Long;
    my ($rc);

    Getopt::Long::Configure(
        'require_order', 'no_gnu_compat', 'auto_abbrev',
        'no_ignore_case', 'bundling');

    $rc = GetOptions ( "help|h" => sub { usage; exit 0 },
                       "delay|d=i" => sub { $cnf{delay} = $_[1] },
                       "endless|e", => sub { $cnf{endless} = 1 } );

    if (!$rc) {
        usage;
        exit 1;
    }
};

my ($fh, $dev, $pty);

sub board_rx {
    my ($input) = @_;
    $input =~ s/[\r\n]+//;
    print " >>> " . $input . "\n";
    sleep $cnf{delay} if ($cnf{delay} > 0);
    return $input;
}

sub board_tx {
    my ($dev, $output) = @_;
    print " <<< " . $output . "\n";
    print $dev "$output\n";
}

$dev = POSIX::Termios->new;
$pty = IO::Pty->new;
$fh = $pty->slave;

print "Connecting to device `" . $fh->ttyname . "'...\n";

# Setup serial device...
$dev->getattr(fileno($fh)) or die "Could not get attributes: $ERRNO\n";

$dev->setispeed(B19200) or die "Could not set input speed: $ERRNO\n";
$dev->setospeed(B19200) or die "Could not set output speed: $ERRNO\n";

$dev->setcflag(($dev->getcflag
                   | (CSIZE | PARENB | CS8 | CREAD | CLOCAL | HUPCL))
                   & ~(IXON | IXOFF));

$dev->setiflag($dev->getiflag
                   | IGNBRK);

$dev->setlflag($dev->getlflag
                   & ~(ICANON | ECHO | ECHONL | ECHOK | ECHONL));

$dev->setoflag($dev->getoflag
                   & ~(OPOST));

$dev->setcc(VMIN, 1);
$dev->setcc(VTIME, 0);

$dev->setattr(fileno($fh), TCSANOW) or die "Could not set attributes: $ERRNO\n";

sub allowed_state {
    my ($state, $allowed) = @_;

    if (ref $allowed eq 'ARRAY') {
        for my $i (@{ $allowed}) {
            return 1 if ($state eq $i);
        }
    } else {
        return 1 if ($state eq $allowed);
    }

    return 0;
}

# Read-Reply loop
$done = 0;
$state = q{init};
RR: while (my $input = <$pty>) {
    my (@cmd, $f, $pstate);

    $pstate = $state;
    $input = board_rx($input);
    @cmd = split /\s+/, $input;
    $f = $cb{$cmd[0]};

    if (defined $f->{code} and ref($f->{code}) eq q{CODE}) {
        my $ret = $f->{code}->(@cmd) if (allowed_state($state, $f->{state}));
        board_tx($pty, (defined $ret) ? $ret : q{WTF});
    } else {
        board_tx($pty, q{UNKNOWN-COMMAND});
    }

    print " -!- Changed state: $pstate -> $state\n" if ($pstate ne $state);
    last RR if ($done);
}

sleep 1;
close $fh;
