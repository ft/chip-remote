;; -*- scheme -*-

;; Copyright (c) 2014 chip-remote workers, All rights reserved.
;;
;; Terms for redistribution and use can be found in LICENCE.

;; When proper care has been taken to implement the second-level access module
;; for any given device, often the code required for third-level access can be
;; very much generated on the fly, because the pattern in the common case is
;; always the same: You read a register from the controlled device, change that
;; original register value using the second-level API, and then write the
;; amended register value back to the device.
;;
;; The ‘define-bit-field-frontends’ macro from the (chip-remote level-3) module
;; expands into function definitions of exactly that kind. And when a
;; configuration bit-field is limited to a single register, then that just
;; works.
;;
;; Still, filling the table that provides ‘define-bit-field-frontends’ macro
;; with the information it needs to expand into useful code, is rather boring.
;; The functions that frontends are needed for are in the second-level access
;; module, and the corresponding register-address variable (defined in the
;; registers module for the device) can be derived from the second-level code
;; as well.
;;
;; So what this script does it *reading* scheme expressions from the source
;; code file that houses the second-level module. Then it traverses through the
;; source code to find the first-level access functions used, from which the
;; corresponding register address can be derived. That course of action also
;; allows the script to find out the argument list for the second-level
;; functions. Without that, no sensible third-level code could be generated.
;;
;; Using that approach, the author of the support for a new target device only
;; has to implement a ‘write-register’ function, a ‘read-register’ functions
;; and front-ends for functionality that does not fall within the common case.
;; In particular, that would be frontends for setting bit-fields that span
;; across multiple registers.

(when (not (= 3 (length (command-line))))
  (format #t "usage: generate-second-level <lvl2-module-file> <name>~%")
  (quit 1))

(use-modules (chip-remote keyword-assoc)
             (ice-9 control)
             (ice-9 format)
             (ice-9 pretty-print)
             (srfi srfi-1))

(define input-file (cadr (command-line)))
(define regmap-name (caddr (command-line)))

(define registers-module #f)
(define combined #f)
(define combined-srcs #f)
(define combined-srcs-w/lvl2 '())
(define postproc #f)
(define regmap #f)
(define interconns #f)
(define regwidth #f)
(define read-only-regs #f)

(define lvl2/export-list #f)

(define (lvl3/process:header hdr)
  (let* ((lvl2-module (car hdr))
         (base-module (take lvl2-module (- (length lvl2-module) 1))))
    (set! registers-module (append base-module '(registers)))
    (format #t ";; Copyright (c) ~d chip-remote workers, All rights reserved.~%"
            (+ 1900 (tm:year (localtime (current-time)))))
    (format #t ";;~%")
    (format #t ";; Terms for redistribution and use can be found in LICENCE.~%~%")
    (format #t "(define-module ~a~%" base-module)
    (format #t "  #:use-module (ice-9 optargs)~%")
    (format #t "  #:use-module (chip-remote decode)~%")
    (format #t "  #:use-module (chip-remote level-3)~%")
    (format #t "  #:use-module (chip-remote protocol)~%")
    (format #t "  #:use-module (~a~%" (append base-module '(program)))
    (format #t "                #:renamer (symbol-prefix-proc 'lvl2/))~%")
    (format #t "  #:use-module ~a~%" registers-module)
    (format #t "  #:export (decode-device~%")
    (format #t "            decode-register~%")
    (format #t "            decode-register-value~%")
    (format #t "            read-register~%")
    (format #t "            setup-connection~%")
    (format #t "            write-register))~%"))
  (newline)
  (format #t "(define (setup-connection conn index)~%")
  (format #t "  (throw 'cr-setup-connection-not-implemented-yet))~%")
  (newline)
  (format #t "(define (read-register conn addr)~%")
  (format #t "  (throw 'cr-read-register-not-implemented-yet))~%")
  (newline)
  (format #t "(define (write-register conn addr value)~%")
  (format #t "  (throw 'cr-write-register-not-implemented-yet))~%")
  (newline)
  (let next ((exp (cdr hdr)))
    (cond ((null? exp) #f)
          ((and (keyword? (car exp))
                (eq? #:export (car exp)))
           (set! lvl2/export-list (cadr exp)))
          (else (next (cdr exp))))))

(define (lvl3/after-import-defines)
  (define ddi (string-length "  (device-decoder "))
  (format #t "(define* (decode-register-value addr value #:key")
  (format #t " (colour? (to-tty?)))~%")
  (format #t "  (value-decoder ~a-register-map" regmap-name)
  (format #t " ~a-register-width addr value colour?))~%" regmap-name)
  (newline)
  (format #t "(define* (decode-register conn addr #:key")
  (format #t " (colour? (to-tty?)))~%")
  (format #t "  (decode-register-value addr (read-register conn addr)")
  (format #t " #:colour? colour?))~%")
  (newline)
  (format #t "(define* (decode-device conn #:key (colour? (to-tty?)))~%")
  (format #t "  (device-decoder #:register-map ~a-register-map~%" regmap-name)
  (format #t "~v_#:reader (lambda (a) (read-register conn a))~%" ddi)
  (format #t "~v_#:decoder (lambda (a v) (decode ~a-register-map a v))~%"
          ddi regmap-name)
  (when interconns
    (format #t "~v_#:interconnections ~a-register-interconns~%"
            ddi regmap-name))
  (format #t "~v_#:filter-predicate #f~%" ddi)
  (format #t "~v_#:width ~a-register-width~%" ddi regmap-name)
  (format #t "~v_#:colour? colour?))~%" ddi)
  (newline))

(define (dump-arglist al)
  (let next ((rest al))
    (if (null? rest)
        #t
        (begin (format #t " ~a" (car rest))
               (next (cdr rest))))))

(define (is-setter? exp)
  (and (symbol? exp)
       (let ((s (symbol->string exp)))
         (and (string-prefix? "set-" s)
              (string-suffix? "-bits" s)))))

(define (find-setter exp)
  (call/ec
   (lambda (return)
     (let search ((rest exp))
       (cond ((null? rest) #f)
             ((list? rest)
              (search (car rest))
              (search (cdr rest)))
             (else
              (and (is-setter? rest)
                  (return rest))))))))

(define (make-regaddr-from-setter exp)
  (symbol-append 'regaddr:
                 (string->symbol (let ((s (symbol->string exp)))
                                   (substring s 4 (- (string-length s) 5))))))

(define (find-register-address exp)
  (let* ((setter (find-setter exp)))
    (if (not setter)
        '(throw 'could-not-find-register-address)
        (make-regaddr-from-setter setter))))

(define (addr->pp addr)
  (format #f "postproc:x~x" addr))

(define (lvl3/process:procedure exp)
  (define (symbol-strip x n)
    (string->symbol (substring (symbol->string x) n)))
  (define (combined-name x)
    (let ((res (or (memq (symbol-strip x 4) combined-srcs)
                   (memq (symbol-strip x 7) combined-srcs)
                   (memq (symbol-strip x 8) combined-srcs))))
      (if res (car res) #f)))
  (let* ((name (caar exp))
         (lvl2 (symbol-append 'lvl2/ (caar exp)))
         (addr (find-register-address (cdr exp)))
         (arglist (cdar exp))
         (literal-addr (eval addr (current-module)))
         (indent (string-length (symbol->string name))))
    (let ((cmb (combined-name name)))
      (cond ((and read-only-regs (member literal-addr read-only-regs))
             (format #t "~%  ;; Register #x~x is readonly, skipping: ~a"
                     literal-addr name))
            ((and cmb (string-prefix? "disable-" (symbol->string name)))
             (format #t "~%  ;; Skipped due to combined entry: ~a" name))
            (cmb (set! combined-srcs-w/lvl2
                       (cons (list cmb name lvl2 addr literal-addr arglist)
                             combined-srcs-w/lvl2))
                 (format #t "~%  ;; Skipped due to combined entry: ~a" name))
            (else (format #t "~%  (~a ~a~%" name addr)
                  (format #t "   ~v_ ~a" indent lvl2)
                  (if (> (length arglist) 1)
                      (format #t " ~a" (cdr arglist)))
                  (let ((pp (assoc literal-addr postproc)))
                    (if pp
                        (format #t
                                "~%   ~v_ ~a"
                                indent
                                (if (procedure? (cadr pp))
                                    (caddr pp)
                                    (addr->pp literal-addr)))))
                  (display ")"))))))

(define (lvl3/generate-post-processors lst)
  (format #t ";; Register post-processors:~%")
  (map (lambda (x)
         (when (pair? (cadr x))
           (let ((addr (car x))
                 (setter (assoc 'set (cdr x)))
                 (unsetter (assoc 'unset (cdr x))))
             (newline)
             (format #t "(define (postproc:x~x value)~% " addr)
             (if unsetter (format #t " (logclear"))
             (if setter (format #t " (logior"))
             (format #t " value")
             (if setter (format #t " #b~b)" (cdr setter)))
             (if unsetter (format #t " #b~b)" (cdr unsetter)))
             (newline))))
       lst)
  (newline))

(define (lvl3/process exp)
  (define (has-pp? x)
    (assq 'post-process (cdr x)))
  (define (got-symbol-pps? lst)
    (cond ((null? lst) #f)
          ((pair? (cadar lst)) #t)
          (else (got-symbol-pps? (cdr lst)))))
  (let ((head (car exp))
        (rest (cdr exp)))
    (cond ((eq? head 'define-module)
           (lvl3/process:header rest)
           ;; The following lines will make some people cringe; but we need
           ;; some strings from the command line to be part of the evaluation
           ;; in this script. Yes, it's ugly. But it's not part of the library
           ;; and also, it works.
           (eval-string (format #f "(use-modules ~a)" registers-module)
                        (current-module))
           (eval-string (format #f
                                "(set! interconns ~a-regmap-interconnections)"
                                regmap-name)
                        (current-module))
           (eval-string (format #f "(set! regmap ~a-register-map)" regmap-name)
                        (current-module))
           (eval-string (format #f "(set! regwidth ~a-register-width)"
                                regmap-name)
                        (current-module))
           (catch #t
             (lambda ()
               (eval-string
                (format #f "(set! read-only-regs ~a-read-only-registers)"
                        regmap-name)
                (current-module)))
             (lambda (k . a) #t))
           (lvl3/after-import-defines)
           ;; If an entry is a combined value, it needs special treatment. So
           ;; let's get a list of them, so we can later check easily for them.
           (set! combined (map (lambda (x)
                                 (let ((dest (kwa-ref x #:into))
                                       (srcs (kwa-ref x #:sources))
                                       (logic (kwa-ref x #:logic))
                                       (splitter (kwa-ref x #:split)))
                                   (list dest
                                         (cons 'sources srcs)
                                         (cons 'logic logic)
                                         (cons 'split splitter))))
                               (filter (lambda (x)
                                         (eq? (car x)
                                              'combine))
                                       interconns)))
           (set! combined-srcs (map car
                                    (concatenate
                                     (map (lambda (x)
                                            (assq-ref (cdr x) 'sources))
                                          combined))))
           ;; When changing entries from registers that include a post-process
           ;; clause, that post-process clause needs to be handled every time.
           ;; This is a record of registers that have such clauses: It maps the
           ;; register's address to its post-process clause.
           (set! postproc (map (lambda (x)
                                 (cons (car x) (assq-ref (cdr x) 'post-process)))
                               (filter has-pp? regmap)))
           (if (got-symbol-pps? postproc)
               (lvl3/generate-post-processors postproc))
           (format #t "(define-bit-field-frontends"))
          ((eq? head 'define)
           (and (list? (car rest))
                (memq (caar rest) lvl2/export-list)
                (lvl3/process:procedure rest)))
          (else #t))))

(define (lvl3/replay-register name idx l2 aname anum args)
  (let* ((s0 "    (replay-register ")
         (l0 (string-length s0))
         (pp (assoc anum postproc)))
    (newline)
    (format #t "~aconn ~a~%" s0 aname)
    (format #t "~v_~a~%" l0 l2)
    (format #t "~v_((list-ref data ~a))" l0 idx)
    (if pp
        (format #t " ~a)" (addr->pp (car pp)))
        (format #t ")"))))

(define (lvl3/replay-register-boolean name type aname anum args)
  (let* ((s0 "    (replay-register ")
         (l0 (string-length s0))
         (pp (assoc anum postproc)))
    (newline)
    (format #t "~aconn ~a~%" s0 aname)
    (format #t "~v_lvl2/~a-~a" l0 type name)
    (if pp
        (format #t " ~a)" (addr->pp (car pp)))
        (format #t ")"))))

(define (lvl3/generate-word-combined x)
  (let* ((name (car x))
         (data (cdr x))
         (srcs (assq-ref data 'sources))
         (split (cadr (assq-ref data 'split))))
    (newline)
    (format #t "(define-public (set-~a conn value)~%" name)
    (format #t "  (let ((data (~a value)))" split)
    (fold (lambda (a acc)
            (let* ((name (car a))
                   (data (assq name combined-srcs-w/lvl2)))
              (if (not data)
                  (begin (format #t ";; No data for ~a...~%" name)
                         (format #t ";; Entry:~%")
                         (pretty-print x #:per-line-prefix ";; ")
                         (format #t ";; combined-data:")
                         (pretty-print combined-srcs-w/lvl2
                                       #:per-line-prefix ";; "))
                  (let ((lvl2 (list-ref data 2))
                        (addr-name (list-ref data 3))
                        (addr-num (list-ref data 4))
                        (arglst (list-ref data 5)))
                    (lvl3/replay-register name acc lvl2
                                          addr-name addr-num
                                          arglst))))
            (+ 1 acc))
          0
          srcs)
    (display "))")
    (newline)))

(define (lvl3/generate-boolean-combined* x type)
  (let* ((name (car x))
         (data (cdr x))
         (srcs (assq-ref data 'sources)))
    (format #t "(define-public (~a-~a conn)" type name)
    (map (lambda (a)
           (let* ((name (car a))
                  (data (assq name combined-srcs-w/lvl2)))
             (if (not data)
                 (begin (format #t ";; No data for ~a...~%" name)
                        (format #t ";; Entry:~%")
                        (pretty-print x #:per-line-prefix ";; ")
                        (format #t ";; combined-data:")
                        (pretty-print combined-srcs-w/lvl2
                                      #:per-line-prefix ";; "))
                 (let ((addr-name (list-ref data 3))
                       (addr-num (list-ref data 4))
                       (arglst (list-ref data 5)))
                   (lvl3/replay-register-boolean name type
                                                 addr-name addr-num
                                                 arglst)))))
         srcs))
  (display ")")
  (newline))

(define (lvl3/generate-boolean-combined x)
  (newline)
  (lvl3/generate-boolean-combined* x 'disable)
  (newline)
  (lvl3/generate-boolean-combined* x 'enable))

(call-with-input-file input-file
  (lambda (p)
    (let next ((exp (read p)))
      (if (eof-object? exp)
          #t
          (begin (lvl3/process exp)
                 (next (read p)))))))
(display ")")
(newline)
(when (not (null? combined))
  (map (lambda (x)
         (let ((name (car x))
               (logic (assq-ref (cdr x) 'logic)))
           (cond ((eq? logic 'word) (lvl3/generate-word-combined x))
                 ((eq? logic 'boolean) (lvl3/generate-boolean-combined x))
                 (else (format #t "~%;; Unknown logic: ~a~%" logic)
                       (format #t ";; Valid logic keys: boolean, word~%")
                       (pretty-print x #:per-line-prefix ";; ")))))
       combined))
